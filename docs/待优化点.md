# 待优化点

以下内容按「收益/风险」优先级排序，可作为后续 2 周内的迭代路线图。

## 1) 状态初始化与副作用入口统一（最高优先级）✅
- 现状问题：仍出现“Maximum update depth exceeded”，说明初始化/同步逻辑分散。
- 目标：每个业务模块只保留一个 init 入口（hook 或 atom init），避免组件内反复 set atom。
- 建议动作：
  - 建立 `useXInit()` 统一副作用入口（监听 tRPC → 同步 atom）。
  - 禁止在 UI 组件内写入全局原子状态。
- 当前进度：
  - 已完成：Playback / Toolbar / Articles / SentenceOps / SettingsDialogs / AiManagement / CardMode / Cloze 均已落到 `useInit*` 入口。
  - 已修复：Toolbar/CardMode/Cloze 从 UI 组件内写 atom 的路径。
- 验收标准：
  - 页面刷新无循环更新警告。
  - 初始化流程可在单一文件中定位。

## 2) tRPC 与 Jotai 同步边界明确 ✅
- 现状问题：数据既保存在 tRPC cache 又写入 atom，易导致漂移与重复同步。
- 目标：tRPC 负责“存取”，Jotai 负责“响应与协作”。
- 建议动作：
  - 只在“跨组件联动/高频 UI/多实例状态”场景落入 atom。
  - 纯展示数据保留在 `trpc.useQuery()` 中。
- 当前进度：
  - Articles：列表数据改为只读 tRPC（不再写入 articles atom）。
  - SettingsDialogs：TTS options 仅来自 query，draft 仍为 UI 状态。
  - AiManagement：已移除 query → draft 种子同步，draft 仅用于对话框编辑态。
  - 扫描：未发现同一文件同时使用 `trpc.useQuery` 与 `useAtom` 的混合读路径。
- 边界检查清单（建议每次重构后过一遍）：
  - 同一业务字段仅允许一个真实来源（query 或 atom）。
  - 组件内不允许“query + atom”混读同一字段。
  - 仅在“跨组件联动/高频 UI/多实例”场景落入 atom。
- 验收标准：
  - 重要数据只有一个“真实来源”。
  - 组件中不再出现“既读 query 又读 atom”的混合逻辑。

## 3) Context 迁移收尾 ✅
- 现状问题：Context 与 Jotai 并存，增加心智负担。
- 目标：只保留必要的初始化 Provider，其他都原子化。
- 建议动作：
  - 列出剩余 Context 与用途，逐个评估是否可由 atom 替代。
  - 保留少量“基础初始化 Provider”（例如订阅服务、全局事件）。
- 当前进度：
  - 已移除 SentenceItem Context（改为组件内部直接消费 hooks/atoms）。
  - createContext 相关用法已清零，页面层不再依赖业务 Context。
  - 全站仅保留 app 级 Provider（tRPC/React Query），无业务 Context 残留。
- 验收标准：
  - 页面层不再依赖业务 Context。
  - Provider 数量显著减少。

## 4) 组件边界继续收敛
- 现状问题：部分组件仍依赖多 props 拼装与透传。
- 目标：组件内部直接消费 atoms/hooks，页面仅负责布局与入口 hook。
- 建议动作：
  - 对高频变更区域（Toolbar / Content / Sidebar）进行 props 缩减。
  - 形成“页面只负责布局 + Hooks 初始化”的稳定模式。
- 验收标准：
  - 页面文件行数进一步降低。
  - props drilling 基本消失。

## 5) 文档与依赖治理
- 现状问题：迁移阶段依赖易回流。
- 目标：保证 feature 之间单向依赖、入口统一。
- 建议动作：
  - 统一从 `features/*/index.ts` 导入，禁止 deep import。
  - 原子默认私有，通过 hook 暴露最小能力。
- 验收标准：
  - 依赖检查通过（无跨模块深层引用）。
  - 新增模块能按规范自动落地。
