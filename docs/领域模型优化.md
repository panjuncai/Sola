基于你提供的代码库（特别是 `Sola架构设计.md`、`article.ts` 和 `useArticleToolbarLogic.ts`），我可以看到目前的架构是典型的 **"T3 Stack + Feature-based"** 模式。

这种模式在初期开发速度很快，但随着业务变复杂（比如你复杂的播放回环逻辑），**"逻辑与框架耦合"** 的问题就开始显现。

目前的“痛点”主要体现在：

1. **后端逻辑脚本化**：在 `packages/api/.../article.ts` 中，业务逻辑（如 `splitArticleContent`）和数据存取（Drizzle/SQL）以及路由控制（tRPC）混在一起。这是典型的**事务脚本（Transaction Script）**模式。
2. **前端逻辑 Hook 化**：在 `useArticleToolbarLogic.ts` 中，极其复杂的播放控制流（循环、影子跟读、预加载）完全依赖 React Hooks (`useEffect`, `useRef`) 实现。这导致逻辑难以单元测试，且难以移植（例如未来做 React Native 版）。
3. **`packages/logic` 为空**：你预留了位置，但还没想好放什么。

---

### 如何优雅地设计领域模型（Domain Model）？

要在 Monorepo 中引入优雅的领域模型，核心思想是：**提取核心逻辑，使其“去框架化”（Framework Agnostic）。**

也就是：**User Logic (Hooks/Routers) -> Pure Logic (Domain/Entities/Services)。**

以下是具体的重构与设计建议：

#### 1. 重新定义 `packages/logic` 的职责

将 `packages/logic` 视为你的 **Core Domain**。它不应该依赖 React，也不应该依赖 tRPC 或 Drizzle（或者仅依赖抽象接口）。它应该是纯 TypeScript 代码。

**建议目录结构：**

```
packages/logic/
├── src/
│   ├── article/
│   │   ├── content-parser.ts   // 纯文本解析逻辑
│   │   └── entity.ts           // Article 类（充血模型）
│   ├── playback/
│   │   ├── engine.ts           // 播放核心状态机（最关键的部分）
│   │   └── scheduler.ts        // 调度器
│   └── shared/

```

---

#### 2. 后端重构：提取纯业务逻辑

**现状：**
在 `apps/server/.../article.ts` 中，`splitArticleContent` 函数直接写在路由文件里。

**改进：**
将文本解析逻辑移入 `packages/logic/src/article/content-parser.ts`。这部分逻辑是“领域知识”（如何定义一个句子），它不依赖数据库。

```typescript
// packages/logic/src/article/content-parser.ts
export class ArticleContentParser {
  static parse(content: string, sourceType: 'word_list' | 'article'): SentenceDraft[] {
    if (sourceType === 'word_list') {
      return this.splitWordList(content);
    }
    return this.splitArticleContent(content);
  }

  private static splitArticleContent(content: string): SentenceDraft[] {
    // ... 原来的正则切分逻辑 ...
    // 这里不仅可以切分，还可以做更复杂的清洗、校验
  }
}

```

**好处：**

* 你可以在 `packages/logic` 里单独为切分逻辑写单元测试，而不需要启动整个后端服务。
* 如果前端在编辑时也需要实时预览切分效果，可以直接复用这个逻辑（Shared Logic）。

---

#### 3. 前端重构：将 Hook 逻辑下沉为“播放引擎” (重点)

**现状：**
`useArticleToolbarLogic.ts` 非常臃肿。它使用了 `useRef` 来追踪 `loopTokenRef`，用 `useEffect` 来处理副作用。这是**最脆弱**的设计点。如果组件重渲染、或者 React 并发模式介入，基于 `ref` 和 `timeout` 的逻辑很容易出 bug。

**改进：**
引入 **UI 无关的类（Class）或状态机（State Machine）** 来管理播放逻辑。

在 `packages/logic/src/playback/PlaybackEngine.ts` 中设计一个核心类：

```typescript
// 这是一个纯 TS 类，不依赖 React
import { makeAutoObservable } from "mobx"; // 或者使用 zustand/vanilla, eventemitter

type PlaybackConfig = {
  nativeRepeat: number;
  targetRepeat: number;
  pauseSeconds: number;
  // ...
}

export class PlaybackEngine {
  // 内部状态
  private isPlaying = false;
  private currentSentenceId: string | null = null;
  private loopMode: 'all' | 'single' | 'target' | 'shadowing' = 'all';
  
  // 外部注入的能力（反转依赖）
  private audioPlayer: AudioInterface; 
  private dataProvider: DataInterface;

  constructor(audioPlayer: AudioInterface, dataProvider: DataInterface) {
    // 如果用 mobx
    // makeAutoObservable(this); 
  }

  // 核心动作，替代原来的 startLoopAllAction
  async startLoop(sentences: Sentence[], config: PlaybackConfig) {
    this.isPlaying = true;
    let index = 0;
  
    while (this.isPlaying && index < sentences.length) {
      const sentence = sentences[index];
    
      // 复杂的调度逻辑移到这里
      await this.playSentenceStrategy(sentence, config);
    
      // 预加载逻辑
      this.preloadNext(sentences, index);
    
      index = this.getNextIndex(index, this.loopMode);
    }
  }

  private async playSentenceStrategy(sentence: Sentence, config: PlaybackConfig) {
     // 这里处理 "native -> pause -> target -> pause" 的流水线
     // 完全不需要 React 的渲染周期参与
  }

  stop() {
    this.isPlaying = false;
    this.audioPlayer.stop();
  }
}

```

**React 层怎么接？**

React 组件只负责**订阅**和**触发**。

```typescript
// apps/web/.../usePlayback.ts

// 单例或者 Context 注入
const engine = new PlaybackEngine(new WebAudioPlayer(), new TrpcDataProvider());

export const usePlayback = () => {
  // 使用 useSyncExternalStore (React 18+) 或者 mobx-react 
  // 将 engine 的状态同步到 React
  const isPlaying = useStore(engine.isPlaying); 
  
  return {
    start: (opts) => engine.startLoop(opts),
    stop: () => engine.stop(),
    isPlaying
  };
};

```

**优雅之处：**

1. **可测试性**：你可以直接 `new PlaybackEngine(mockAudio, mockData)` 并在 Jest 中测试“循环是否正确跳转”、“影子跟读是否重复了3次”，完全不需要渲染组件。
2. **稳定性**：逻辑不再受 React `useEffect` 闭包陷阱或重渲染的影响。`while` 循环在纯 JS 线程中运行，极其稳定。
3. **清晰度**：`useArticleToolbarLogic.ts` 将变成一个只有几十行的纯粹的 Controller，负责将 UI 事件转发给 Engine。

---

#### 4. 领域对象（Entities）的充血模型化

目前的 `Sentence` 只是一个 JSON 数据接口（Interface）。

```typescript
// 贫血模型 (Anemic Model)
interface Sentence {
  nativeText: string;
  targetText: string;
}

// 业务代码里到处散落着这种判断
if (sentence.nativeText && !sentence.targetText) { ... }

```

**改进：**
在 `packages/logic` 中定义实体类，或者包含逻辑的 Helper。

```typescript
// packages/logic/src/domain/Sentence.ts

export class SentenceEntity {
  constructor(public data: SentenceDTO) {}

  // 领域行为
  get isClozeAvailable(): boolean {
    return !!this.data.targetText && this.data.targetText.length > 3;
  }

  get hasNativeAudio(): boolean {
    return !!this.data.nativeText;
  }
  
  // 甚至包含简单的格式化逻辑
  get primaryDisplayRole(): 'native' | 'target' {
    // ...
  }
}

```

这样前端 UI 组件只管调用 `sentence.isClozeAvailable`，而不用关心具体的判断逻辑（比如长度大于3还是大于5，以后改了只改一处）。

---

#### 5. 总结：建议的演进路线

不要一次性推倒重来。建议按以下步骤逐步重构：

1. **提取纯函数 (Easy)**：

* 把后端 `splitArticleContent` 移到 `packages/logic`。
* 把前端 `useArticleToolbarLogic.ts` 里的 `buildLocalCacheKey` 等纯计算函数移到 `packages/logic`。

2. **重构播放核心 (Hard but High Value)**：

* 创建一个 `PlaybackScheduler` 类。
* 将 `startLoopAll` 等函数里的 `while` 循环逻辑剥离出 React Hook，放入这个类中。
* 让 Hook 仅仅持有这个类的实例。

3. **统一类型定义**：

* 确保 `packages/shared` 里的类型被 `logic`、`api` 和 `web` 共同引用，作为通用语言（Ubiquitous Language）。

**一句话总结：**
让 React 专注做 **UI 的渲染与交互（View）**，让 tRPC 专注做 **数据的传输（Controller）**，将 **怎么切分句子、怎么调度播放顺序（Model/Domain）** 全部收敛到 `packages/logic` 中。这就是最优雅的领域模型设计。
