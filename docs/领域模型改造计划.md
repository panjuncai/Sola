# 领域模型改造计划

基于当前代码库的复杂度与可维护性挑战，采用“**逻辑去框架化（Framework-Agnostic）**”的领域模型方向。目标是把核心业务逻辑下沉到 `packages/logic`，让 React/tRPC 只承担 View/Controller 角色。

## 目标与收益

- **稳定性**：核心逻辑不依赖 React 生命周期与 Hook 闭包。
- **可测试性**：核心逻辑可直接单元测试（Jest/Vitest）。
- **可迁移性**：未来扩展到 RN / Electron 仅需替换 UI 层。
- **可维护性**：减少 Hook 膨胀与 UI 状态/流程纠缠。

---

## 阶段 0：准备与边界定义（1–2 天）

目标：为 `packages/logic` 确立边界与定位，防止被 UI/DB 侵入。

### 动作
- [x] 明确 `packages/logic` 只依赖 `packages/shared`
- [x] 新增/完善边界检查脚本（禁止 logic 引入 web/ui/db）
- [x] 创建 `packages/logic/src` 目录结构（article/playback/utils）

```
packages/logic/
  src/
    article/
    playback/
    utils/
```

### 验收
- [ ] logic 可独立 build
- [ ] lint/边界规则通过（含 logic 边界脚本）
- [x] `utils/` 仅供 logic 内部复用，不对外暴露

---

## 阶段 1：提取纯函数（低风险，高收益）

目标：先迁移“纯逻辑”，建立领域层最小价值闭环。

### 动作
- [x] 将 `splitArticleContent` 从 `apps/server/.../article.ts` 抽到 `packages/logic/src/article/content-parser.ts`
- [x] 将前端的纯文本处理/正则拆分逻辑统一迁移到 `logic`
- [x] 前后端同时复用该逻辑

### 验收
- 前端/后端均使用 `packages/logic` 的 parser
- 行为完全一致

---

## 阶段 2：播放逻辑下沉（高价值）

目标：抽离 `useArticleToolbarLogic.ts` 的复杂循环/影子跟读逻辑，形成可测试的播放引擎。

### 动作
- [ ] 新建 `packages/logic/src/playback/engine.ts`
- [ ] 设计 `PlaybackEngine`（类 or 状态机）
- [ ] React Hook 只负责桥接、订阅引擎状态
- [ ] 封装 Audio 接口 / Data Provider 接口（依赖反转）

### 验收
- Engine 独立单测覆盖核心播放逻辑
- Hook 代码量显著下降

---

## 阶段 3：领域对象充血（Entity）

目标：业务判断集中到实体类，UI 不再到处写逻辑 if。

### 动作
- [ ] 新建 `SentenceEntity` / `ArticleEntity`
- [ ] 将 “可挖空/是否可播放/主展示角色”等逻辑迁入实体
- [ ] UI 只调用实体方法或 getter

### 验收
- UI 逻辑明显减少
- 规则变更只改实体层

---

## 阶段 4：统一 Ubiquitous Language

目标：前后端、logic 共享统一类型语言。

### 动作
- [ ] 统一 DTO 放入 `packages/shared`
- [ ] `logic` / `web` / `api` 使用 shared 类型
- [ ] 删除重复类型定义

### 验收
- 类型定义唯一来源
- 前后端逻辑可互相复用

---

## 里程碑验收清单

- [ ] logic 目录已建立 + 边界规则通过
- [ ] Article 解析逻辑已下沉并复用
- [ ] PlaybackEngine 可测试、UI Hook 变薄
- [ ] 领域实体类承载核心判断逻辑
- [ ] shared 统一类型语言落地

---

## 推荐执行顺序

1. 阶段 1（纯函数提取）  
2. 阶段 2（播放引擎）  
3. 阶段 3（实体模型）  
4. 阶段 4（类型统一）

---

## 备注

此计划 **不要求一次性重构**，可分阶段逐步落地，每个阶段均可独立验收并回滚。
