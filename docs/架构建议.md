# 架构建议

本文基于当前项目架构（tRPC + Jotai + Zustand + Feature 模块化）给出可执行的架构改进建议，目标是：**长期可维护、可演进、可替换**。

---

## 1) 选型建议（保持不变，但强化边界纪律）
- 现有组合合理：  
  - **tRPC**：Server State（存取与缓存）  
  - **Jotai**：UI / Local State（高频交互、跨组件联动）  
  - **Zustand**：Global State（Auth / 全局 Settings）
- 关键问题不是选型，而是**边界回流**。
- 重点落地：导入边界 + 原子私有化 + Hook 入口统一。

---

## 2) 分层标准（固定 4 层）
每个 feature 统一遵循：
1. **API/Server State**：tRPC Query / Mutation  
2. **UI/Local State**：Jotai atoms  
3. **业务编排**：hooks（唯一入口）  
4. **UI 组件**：尽量纯渲染

> 目标：组件内不写全局原子、不做跨模块编排。

---

## 3) 初始化入口统一（持续收益最高）
- 采用 `useInit*` 作为模块初始化唯一入口。
- Page 层只调用一次，不允许在 UI 组件内重复 set atom。

**规则**：
- `useInit*` 写入 atom  
- `use*State / use*Actions` 只消费  
- UI 组件禁止直接操作全局原子

---

## 4) 模块边界与导入规则
**导入统一从 feature 入口导出**：
- ✅ `import { useArticles } from "@/features/articles"`
- ❌ `import { useArticles } from "@/features/articles/hooks/useInitArticles"`

**原子私有化**：
- atoms 不对外导出，外部只能通过 hooks 接口读写。

**边界检测（自动化）**：
- `scripts/check-feature-boundary.mjs`：禁止跨模块 deep import。
- `scripts/check-atom-privacy.mjs`：禁止非 hooks 直接引用 atoms。

---

## 5) 组件拆分标准
拆分不是越细越好，必须满足以下条件之一：
- 有独立交互逻辑（比如播放/选择/输入）
- 可复用的渲染片段
- 可独立测试

否则维持合并组件，避免过度抽象。

---

## 6) 模块可删除性原则
每个 feature 模块都应该具备“可拔插性”：
- 移除 `card-mode` 不影响主流程
- 移除 `ai-management` 不影响文章基础功能

> 这是架构成熟度的重要指标

---

## 7) 建议落地清单
- [x] 统一入口 `useInit*` 完整覆盖  
- [x] 所有 atom 改为私有，只暴露 hooks  
- [x] ESLint 规则：禁止跨模块 deep import  
- [x] 边界脚本：feature/atom 私有化检查纳入 `check:boundary`
- [x] 新增 `features/*/index.ts` 作为唯一出口  
- [x] 页面层仅保留布局 + 初始化调用  

---

## 8) 长期收益
执行以上规范后，系统将具备：
- 更低心智负担（逻辑清晰、路径统一）
- 更好的可维护性（模块边界稳定）
- 更容易新增功能（按 feature 插件式增长）
