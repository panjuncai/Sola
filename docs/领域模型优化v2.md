基于你提供的代码文件，尤其是 `useArticleToolbarLogic.ts` 和 `packages/logic/src/playback/engine.ts`，我对目前的“领域模型”改造进度进行了详细审查。

**结论先行：**

你已经迈出了关键的一步（分离了 Entity 和单句播放逻辑），但目前的架构处于 **“半成品”** 状态。

**核心痛点**在于：**你抽离了“原子逻辑”（怎么播一句话），但把“编排逻辑”（怎么播下一句、怎么循环、怎么中断）依然留在了 React 的 Hooks 里。**

这导致 `useArticleToolbarLogic.ts` 依然是一个 **“上帝 Hook”** (God Hook)，它既要管 UI 状态（Menu open/close），又要管复杂的异步循环控制（while loop, refs）。

以下是具体的审查意见和通往“更优雅架构”的建议：

### 1. 现状审查 (Code Review)

#### ✅ 做得好的地方

1. **Entity 充血模型落地** ：`SentenceEntity` 和 `ArticleEntity` 成功收敛了数据展示逻辑。UI 层现在只需要调用 `entity.isPlayable()`，而不需要写 `if (text && text.length > 0)` 这种代码。
2. **原子播放能力解耦** ：`PlaybackEngine` 成功将“一句话的影子跟读、重复次数、暂停间隔”封装成了一个纯异步函数 `playSentence`。这部分逻辑是完全可测试的。

#### ❌ 待优化的问题 (Pain Points)

1. **控制流依然耦合在 Hook 中** ：
   在 `useArticleToolbarLogic.ts` 中，`startLoopAll`、`startLoopTarget` 函数内部使用了 `while` 循环和 `for` 循环来控制播放顺序。

* **问题** ：这使得播放器的“列表管理”和“播放策略”依然依赖 React 的上下文（比如 `params` 传参）。
* **后果** ：你不得不使用 `loopTokenRef` 这种脆弱的方式来处理“中断”和“竞态问题”。如果用户快速切换模式，Ref 的状态管理会变得非常复杂且容易出错。

1. **Engine 过于“贫血”** ：
   目前的 `PlaybackEngine` 只知道“怎么播当前这一句”，它 **不知道** “下一句是谁”。它就像一个仅仅会发声的喇叭，而拿着乐谱指挥的人依然是 React 组件。
2. **预加载逻辑（Prefetch）入侵** ：
   `prefetchAudio` 直接混在循环逻辑里。这属于一种“副作用”，应该由播放引擎内部的“调度器”自动处理，而不是让 UI 层显式调用。

---

### 2. 如何设计得更优雅？ (Evolution Strategy)

要做到更优雅，你需要引入 **“播放调度器 (Scheduler)”** 的概念，将 **控制权（Control Flow）** 完全移交给 Logic 层。

**核心思想：React 只负责“发指令”和“渲染状态”，不负责“过程控制”。**

#### 步骤一：升级 PlaybackEngine（引入状态与播放列表）

不要让 React 告诉 Engine “播第1句...播第2句”，而是把**整个列表**交给 Engine。

**新版 Engine 设计思路 (伪代码):**

**TypeScript**

```
// packages/logic/src/playback/PlaybackScheduler.ts
import { makeAutoObservable } from "mobx" // 或使用简单的发布订阅模式

export class PlaybackScheduler {
  // 1. 内部持有状态（去 React 化）
  private _queue: PlaybackSentence[] = [];
  private _currentIndex: number = 0;
  private _status: 'idle' | 'playing' | 'paused' = 'idle';
  private _mode: 'loop-all' | 'single' | 'shadowing' = 'loop-all';
  
  // 2. 依赖注入（保持纯净）
  constructor(
    private engine: PlaybackEngine, // 原来的单句播放器
    private audioProvider: AudioProvider // 获取音频 URL
  ) {
    // makeAutoObservable(this) // 如果想让 React 自动响应
  }

  // 3. 核心 API
  loadPlaylist(sentences: PlaybackSentence[], initialIndex = 0) {
    this._queue = sentences;
    this._currentIndex = initialIndex;
  }

  async start() {
    this._status = 'playing';
    // 核心循环逻辑移到这里，不再依赖 React Ref
    while (this._status === 'playing') {
      const sentence = this._queue[this._currentIndex];
    
      // 1. 触发 UI 更新（通过回调或 Mobx）
      this.onSentenceChange?.(sentence.id); 

      // 2. 预加载下一句（内部处理副作用）
      this.prefetchNext();

      // 3. 播放当前句 (调用你现在的原子 Engine)
      await this.engine.playSentence(sentence, ...);

      // 4. 计算下一个索引 (策略模式)
      this._currentIndex = this.nextStrategy(this._currentIndex, this._mode);
    }
  }

  stop() {
    this._status = 'idle';
    // Engine 内部检查 status 自动跳出循环，不需要 tokenRef
  }
}
```

#### 步骤二：UI 层变为“遥控器”

重构后的 `useArticleToolbarLogic.ts` 将会变得非常薄。它不再包含 `while` 循环，只包含对 `scheduler` 的调用。

**TypeScript**

```
// apps/web/.../useArticleToolbarLogic.ts

export const useArticleToolbarLogic = (...) => {
  // 保持 Scheduler 单例
  const [scheduler] = useState(() => new PlaybackScheduler(...));

  // 仅仅是转发指令
  const startLoopAll = () => {
    scheduler.setMode('loop-all');
    scheduler.loadPlaylist(detail.sentences, currentIndex);
    scheduler.start();
  };

  const stopPlayback = () => {
    scheduler.stop();
  };

  // 通过订阅获取当前播放状态（这就优雅了，不再是通过 Ref 来回传）
  const isPlaying = useStore(scheduler.status === 'playing');
  const currentId = useStore(scheduler.currentSentenceId);

  return { startLoopAll, stopPlayback, isPlaying, currentId ... };
}
```

### 3. 具体落地建议

1. **废弃 `loopTokenRef`** ：
   这是代码中最“脏”的部分。将状态移入 Class 后，你可以用 `this.status` 标记来控制循环退出，因为 Class 实例是持久的，不会受 React Render 闭包影响，天然解决了竞态问题。
2. **提取 `Strategy` 模式** ：
   目前的 `startLoopAll`, `startLoopTarget` 代码高度重复。
   在 Logic 层定义一个 `NextIndexStrategy` 接口：
   **TypeScript**

```
   type NextIndexStrategy = (current: number, total: number) => number;

   const LoopAllStrategy = (c, t) => (c + 1) % t;
   const SingleStrategy = (c, t) => c;
```

   这样 Engine 只需要根据模式切换 Strategy，只有一份 `while` 循环代码。

1. **响应式连接** ：
   考虑到你不想引入 Mobx 等重库，可以使用轻量级的 `zustand/vanilla` 或者简单的 `Listeners` 数组在 Engine 和 Hook 之间同步 `currentSentenceId`。

### 总结

现在的代码是  **Logic V1.0** （提取了名词和动词），优雅的架构需要进化到  **Logic V2.0** （提取**句子**和 **文章** ）。
