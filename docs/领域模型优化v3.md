你已经成功地完成了**“控制流下沉”**。现在的 `useArticleToolbarLogic` 不再是一个包含复杂 `while` 循环和 `Ref` 状态管理的“面条代码”，而变成了一个相对清晰的**控制器（Controller）**，它主要负责组装参数和发送指令。

**结论先行：**

目前的模式已经达到了 **“生产可用（Production Ready）”** 的标准，比之前的版本优雅得多。

但在 **“领域驱动设计（DDD）”** 的纯度上，它还处于 **V2.0** 阶段。如果你追求  **V3.0 的极致优雅** ，目前还有两个核心问题需要解决：

1. **业务逻辑泄露（Leaky Logic）** ：Hook 依然在定义“什么是目标模式”。
2. **实例生命周期脆弱（Fragile Lifecycle）** ：Scheduler 的创建依赖 React 的 `useMemo` 依赖项，这在 React 中是反模式（React 不保证 `useMemo` 的语义缓存，且依赖变化会导致 Scheduler 重建，打断播放）。

以下是详细的审查和优化建议：

---

### 1. 依然存在的痛点 (The "Smells")

#### 痛点一：Hook 依然知道得“太多了” (Leaky Abstraction)

请看你的 `startLoopTarget` 函数：

**TypeScript**

```
// apps/web/.../useArticleToolbarLogic.ts
scheduler.updateOptions({
  // 这里！Hook 在定义“目标模式”的具体行为逻辑
  getRoleOrder: () => ["target"], 
  getPrefetchRoles: () => ["target"],
})
scheduler.setMode("loop-target")
```

**问题：**

“目标模式（Loop Target）只播放 target 角色” —— 这是一条 **核心业务规则** 。

现在的写法是：**Logic 层（Scheduler）只提供了机制（Mechanism），而 View 层（Hook）在定义策略（Policy）。**

如果未来你需要在另一个界面（比如“每日推荐”）也实现“目标模式”，你得把这段 `getRoleOrder` 的配置代码复制一遍。这就违背了 DRY 原则。

#### 痛点二：Scheduler 的生命周期受制于 UI 数据

**TypeScript**

```
// apps/web/.../useArticleToolbarLogic.ts
const scheduler = React.useMemo(
  () => new PlaybackScheduler(...),
  [
    // 危险！如果这些 props 任何一个发生变化（哪怕是引用变化），
    // Scheduler 就会被销毁重建！这会导致播放突然停止。
    audioProvider, 
    playbackEngine,
    playbackNativeRepeat, 
    ...
  ]
)
```

**问题：**

`audioProvider` 或 `playbackEngine` 在 React 中很可能是每次 Render 都生成的新对象（除非你非常小心地缓存了它们）。一旦重建 Scheduler，内部的 `queue` 和 `status` 就会丢失。

**正确做法：** Scheduler 应该像 `Ref` 一样稳定，它的配置更新应该通过 `updateOptions` 完成，而不是通过重建实例。

---

### 2. 优化方案 (Evolution to V3.0)

#### 优化一：将“播放策略”内聚到 Logic 层

不要让 Hook 传 `getRoleOrder` 回调，而是让 Scheduler 内部根据 `mode` 决定行为。

**建议改造 `PlaybackScheduler`：**

引入 **`PlaybackModeStrategy`** 概念，不仅包含 `NextIndex`，还包含 `RoleOrder`。

**TypeScript**

```
// packages/logic/src/playback/types.ts
export interface PlaybackStrategy {
  nextIndex: (current: number, total: number) => number;
  getRoleOrder: (baseOrder: PlaybackRole[]) => PlaybackRole[];
}
```

**TypeScript**

```
// packages/logic/src/playback/strategies.ts
export const strategies: Record<PlaybackMode, PlaybackStrategy> = {
  "loop-target": {
    nextIndex: (c, t) => (t <= 0 ? 0 : (c + 1) % t),
    getRoleOrder: () => ["target"], // 策略定义在这里！
  },
  "loop-all": {
    nextIndex: (c, t) => (t <= 0 ? 0 : (c + 1) % t),
    getRoleOrder: (base) => base,
  },
  // ...
};
```

**Hook 的调用变得极其简单：**

**TypeScript**

```
// Hook 只需要做一件事：设置模式
const startLoopTarget = () => {
  // ... 实体检查 ...
  scheduler.loadPlaylist(detail.sentences, startIndex);
  scheduler.setMode("loop-target"); // Scheduler 内部自动应用 loop-target 的策略
  scheduler.start(buildRoleOrder(displayOrderSetting));
};
```

这样，业务规则完全收敛到了 `packages/logic` 中。

---

#### 优化二：稳定 Scheduler 实例 (Stable Reference)

将 Scheduler 的生命周期与 React Render 解耦。

**建议写法：**

**TypeScript**

```
// apps/web/.../useArticleToolbarLogic.ts

// 1. 使用 useState lazy init 或 useRef 确保 Scheduler 只创建一次
const [scheduler] = React.useState(() => {
  // 初始创建一个“空壳”或者默认配置的 scheduler
  return new PlaybackScheduler(
    new PlaybackEngine(...), // Engine 也可以在这里初始化
    { ...defaultOptions }
  );
});

// 2. 使用 useEffect 同步配置 (Reactive Options)
React.useEffect(() => {
  scheduler.updateOptions({
    pauseMs: ...,
    repeats: ...,
    audioProvider: audioProvider, // 即使 provider 变了，只是更新配置，不重建实例
    onError: onPlayError,
  });
}, [scheduler, playbackPauseSeconds, playbackNativeRepeat, audioProvider, onPlayError]);

// 3. 销毁逻辑
React.useEffect(() => {
  return () => scheduler.stop();
}, [scheduler]);
```

这样，无论 Props 怎么变，`scheduler` 实例永远是同一个 (`===`)，只有它的内部配置在变。这彻底杜绝了“配置变更导致播放中断”的隐患。

---

#### 优化三：数据驱动的 AudioProvider (可选但推荐)

目前的 `audioProvider` 依赖 Hook 里的 `requestSentenceAudio` 等闭包。这使得 Logic 层难以独立测试（必须 Mock 整个 Hook 环境）。

**更优雅的设计：**

将 `AudioSourceProvider` 设计为纯类，不依赖 React Hooks。

**TypeScript**

```
// apps/web/src/lib/WebAudioProvider.ts
export class WebAudioProvider implements AudioSourceProvider {
  constructor(private trpcClient: TrpcClient) {}

  prefetch(sentence: PlaybackSentence, role: PlaybackRole) {
    // 直接调用 tRPC client 或 fetch，不经过 React Hook
    // 管理自己的 LRU Cache Map
  }
}
```

然后在 Hook 里：

`const audioProvider = React.useMemo(() => new WebAudioProvider(trpcUtils), [])`

---

### 3. 代码审查清单 (Checklist for You)

基于以上分析，建议你执行以下具体的修正动作：

* [ ] **重构 Strategies** ：在 `packages/logic/src/playback/strategies.ts` 中，不仅返回 `NextIndexStrategy`，还要把 `getRoleOrder` 的逻辑包含进去。
* [ ] **简化 Hook** ：删除 `useArticleToolbarLogic.ts` 中所有的 `getRoleOrder: () => ...` 回调定义。
* [ ] **稳定实例** ：将 `useMemo(() => new Scheduler)` 改为 `useState(() => new Scheduler)`，确保 Scheduler 实例的 **引用稳定性** 。
* [ ] **修复依赖** ：`playbackEngine` 也是通过 `useMemo` 创建的，它也需要稳定，或者直接在 Scheduler 内部实例化。

### 总结

你现在的代码处于 **V2.5** 水平。

* **V1** : 逻辑混在 UI 组件里。
* **V2** : 逻辑提取了，但 View 层还在手把手教 Logic 层“怎么做业务”（Passing callbacks for rules）。
* **V3 (Target)** : View 层只告诉 Logic 层  **“意图（Intent）”** （例如：`setMode('loop-target')`），Logic 层自己知道该怎么做。

**一句话建议：**

请实施  **“优化二：稳定 Scheduler 实例”** ，这是修复潜在 Bug 的关键；然后实施  **“优化一：策略内聚”** ，这是让代码真正优雅的关键。
